<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DeFire â€” Portfolio & FIRE</title>
  <script src="https://cdn.jsdelivr.net/npm/tronweb@5.3.0/dist/TronWeb.min.js"></script>
  <style>
    :root{--bg:#0b0b0f;--card:#121214;--accent:#ff6600;--muted:#9aa;--ok:#00ffc3}
    body{font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(135deg,#0b0b0f,#1a0a00);color:#fff;margin:0;padding:18px;display:flex;justify-content:center}
    .wrap{width:100%;max-width:980px}
    header{display:flex;align-items:center;gap:14px;justify-content:space-between}
    h1{margin:6px 0;font-size:1.4rem}
    nav{display:flex;gap:8px}
    button.tab{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:#fff;cursor:pointer}
    .active{background:var(--accent);color:#000;border-color:var(--accent)}
    .card{background:rgba(255,255,255,0.03);padding:14px;border-radius:12px;margin-top:14px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    .row{display:flex;gap:10px;align-items:center;margin:8px 0;flex-wrap:wrap}
    label{min-width:140px;opacity:.9}
    textarea,input[type=text],input[type=number]{flex:1;padding:10px;border-radius:8px;border:none;background:#0f1113;color:#fff;min-width:0}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-family:ui-monospace,monospace}
    .muted{color:var(--muted);font-size:0.9rem}
    .total{font-size:1.25rem;font-weight:800;text-align:center;margin-top:12px}
    .small{font-size:.9rem;opacity:.85}
    .addr{font-family:ui-monospace,monospace;color:#9fd8ff}
    .ok{color:var(--ok)}
    .spinner{width:16px;height:16px;border:3px solid rgba(255,255,255,0.12);border-top:3px solid var(--accent);border-radius:50%;animation:spin 1s linear infinite;display:inline-block;vertical-align:middle}
    @keyframes spin{to{transform:rotate(360deg)}}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
    footer{margin-top:14px;color:#cfcfcf;text-align:center;font-size:.85rem}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>ðŸ”¥ DeFire â€” Portfolio & FIRE</h1>
        <div class="muted">On-chain pricing (WinkLink) â€¢ Tronscan token discovery â€¢ manual wallet input</div>
      </div>
      <nav>
        <button id="tabPortfolio" class="tab active">Portfolio</button>
        <button id="tabFire" class="tab">FIRE Calculator</button>
      </nav>
    </header>

    <!-- Wallet / Access card -->
    <div class="card" id="accessCard">
      <div class="row"><label>Connected wallet</label><div class="pill addr" id="connected">Not connected</div></div>
      <div class="row"><label>FBA balance</label><div class="pill" id="fba">â€”</div></div>
      <div class="row"><label>Access</label><div class="pill" id="status">Connect TronLink to begin</div></div>
      <div class="row">
        <button id="btnConnect">ðŸ”— Connect TronLink</button>
        <div class="muted" style="margin-left:auto">Whitelist: owner OR â‰¥1000 FBA unlocks Portfolio</div>
      </div>
    </div>

    <!-- Portfolio tab -->
    <div id="portfolioPane" class="card">
      <h3 style="margin:0 0 8px">Portfolio â€” manual wallet input</h3>

      <div class="row">
        <label>Wallets (one per line)</label>
        <textarea id="walletsText" placeholder="Paste T... addresses here, one per line" rows="5"></textarea>
      </div>

      <div class="row">
        <label>Optional: token contracts to check</label>
        <input id="tokenContractsInput" placeholder="TUSDT..., TUSDC..., TFBA..., comma separated"/>
      </div>

      <div class="row">
        <label>Optional: JustLend comptroller or jTokens</label>
        <input id="justlendInput" placeholder="Comptroller or comma-separated jTokens"/>
      </div>

      <div class="row">
        <button id="btnCalcNet">ðŸ§® Calculate Net Worth (on-chain)</button>
        <div id="progress" class="pill">Idle</div>
      </div>

      <div class="total" id="grand">Grand Total: â€”</div>

      <div style="margin-top:12px">
        <strong>Unpriced / Manual</strong>
        <div id="unpriced" class="muted">No results yet</div>
      </div>

      <div style="margin-top:12px">
        <button id="btnExport" class="tab">Export JSON</button>
        <button id="btnShowConsole" class="tab">Show details (console)</button>
      </div>
    </div>

    <!-- FIRE tab -->
    <div id="firePane" class="card" style="display:none">
      <h3 style="margin:0 0 8px">FIRE Calculator</h3>
      <div class="row"><label>Yearly expenses (CAD)</label><input id="expenses" type="number" placeholder="e.g. 24000" /></div>
      <div class="row"><label>Current savings (CAD)</label><input id="current" type="number" placeholder="e.g. 116247" /></div>
      <div class="row"><label>Yearly savings (CAD)</label><input id="savings" type="number" placeholder="e.g. 20000" /></div>
      <div class="row"><label>Expected APY (%)</label><input id="apy" type="number" placeholder="e.g. 7" /></div>
      <div class="row"><button id="btnCalcFire">ðŸ”¥ Calculate FIRE</button><div id="fireResult" class="pill">Idle</div></div>
      <div id="fireOutput" style="margin-top:12px" class="muted"></div>
    </div>

    <footer style="margin-top:16px">Client-side only â€¢ No private keys leave your browser â€¢ Open in TronLink (mobile) or TronLink extension (desktop)</footer>
  </div>

<script>
/* ================== CONFIG ==================
   Edit these mappings if you want to add extra known oracles.
   ORACLE_BY_SYMBOL: WinkLink feed addresses (mainnet)
   ORACLE_BY_CONTRACT: explicit tokenContract => oracleAddress
   OWNER_WALLET: owner bypass
   FBA_CONTRACT: Football Alien token contract
   FBA_MIN: how many tokens required to unlock
   ============================================ */

const OWNER_WALLET = "TY691Xr2EWgKJmHfm7NWKMRJjojLmS2cma";
const FBA_CONTRACT = "TNW5ABkp3v4jfeDo1vRVjxa3gtnoxP3DBN";
const FBA_MIN = 1000;

const ORACLE_BY_SYMBOL = {
  TRX: "TR5HtpPK4gX4RFC4DCBUHfFgsGkGFEzSAb",
  USDT: "TKePc46n5CiUCR8LL788TFeKA4kjvNnuem",
  USDC: "TNu3zS55MP4KnBBP6aw1nHSzRpc3CXAxm",
  SUN: "TRMgzSPsuWEcVpd5hv19XtLeCk8Z799sZa",
  JST: "TE5rKoDzKmpVAQp1sn7x6V8biivR3d5r47",
  BTT: "TBAAW545oJ6iTxqzezVagrSUzCpz1S8eR",
  BTC: "TQoijQ1iZKRgJsAAWNPMu6amgtCJ3WMUV7",
  ETH: "TR2yWYWovJaSM7TfZq7L7sT7ZRugdJJQmL"
};

const ORACLE_BY_CONTRACT = {
  // "TTokenContract...": "TOracleAddress..."
};

// Tronscan token endpoint
const TSCAN_TOKENS   = addr => `https://apilist.tronscanapi.com/api/account/tokens?address=${addr}&limit=200`;

/* ===== DOM ===== */
const elConnected = document.getElementById("connected");
const elFba = document.getElementById("fba");
const elStatus = document.getElementById("status");
const elBtnConnect = document.getElementById("btnConnect");
const elBtnCalcNet = document.getElementById("btnCalcNet");
const elProgress = document.getElementById("progress");
const elGrand = document.getElementById("grand");
const elUnpriced = document.getElementById("unpriced");
const elWalletsText = document.getElementById("walletsText");
const elTokenContractsInput = document.getElementById("tokenContractsInput");
const elJustlendInput = document.getElementById("justlendInput");
const elExport = document.getElementById("btnExport");
const elShowConsole = document.getElementById("btnShowConsole");

const elTabPortfolio = document.getElementById("tabPortfolio");
const elTabFire = document.getElementById("tabFire");
const portfolioPane = document.getElementById("portfolioPane");
const firePane = document.getElementById("firePane");

/* ===== state ===== */
let tronWebInstance = null;
let connectedAddr = "";
let lastResult = null;

/* ===== helpers ===== */
const sleep = ms => new Promise(r => setTimeout(r, ms));
const toNumberFromRaw = (rawBigInt, decimals) => {
  try {
    const scale = 10n ** BigInt(decimals);
    const intPart = rawBigInt / scale;
    const frac = rawBigInt % scale;
    let fracStr = frac.toString().padStart(decimals,"0");
    fracStr = fracStr.slice(0,8).replace(/0+$/,"");
    const s = fracStr ? `${intPart.toString()}.${fracStr}` : `${intPart.toString()}`;
    return Number(s);
  } catch(e) { return 0; }
};
const fmtUSD = n => Number(n).toLocaleString(undefined,{style:"currency",currency:"USD",maximumFractionDigits:2});

/* ===== tab handlers ===== */
elTabPortfolio.onclick = () => { elTabPortfolio.classList.add("active"); elTabFire.classList.remove("active"); portfolioPane.style.display="block"; firePane.style.display="none"; };
elTabFire.onclick = () => { elTabFire.classList.add("active"); elTabPortfolio.classList.remove("active"); portfolioPane.style.display="none"; firePane.style.display="block"; };

/* ===== TronLink connect & whitelist ===== */
elBtnConnect.onclick = async () => {
  if(!window.tronWeb || !window.tronWeb.ready){
    elStatus.innerHTML = '<span style="color:#ffd166">Open in TronLink and unlock</span>';
    return;
  }
  tronWebInstance = window.tronWeb;
  connectedAddr = tronWebInstance.defaultAddress.base58 || "";
  elConnected.textContent = connectedAddr || "Unknown";
  elStatus.innerHTML = '<span class="muted">Checking whitelistâ€¦ <span class="spinner"></span></span>';
  const ok = await checkWhitelist(connectedAddr);
  if(ok) {
    elStatus.innerHTML = '<span class="ok">Access granted</span>';
  }
};

/* check whitelist: owner or FBA >= FBA_MIN */
async function checkWhitelist(addr){
  try{
    if(!tronWebInstance) return false;
    if(addr === OWNER_WALLET){ elFba.textContent = "Owner"; return true; }
    const c = await tronWebInstance.contract().at(FBA_CONTRACT);
    const raw = await c.balanceOf(addr).call().catch(()=>0);
    let dec = 6;
    try{ const d = await c.decimals().call(); dec = Number(d?.toString?.() ?? d ?? 6); }catch(_){}
    const bal = toNumberFromRaw(BigInt(raw?.toString?.() ?? raw ?? "0"), dec);
    elFba.textContent = `${bal.toLocaleString(undefined,{maximumFractionDigits:6})} FBA`;
    if(bal >= FBA_MIN) return true;
    elStatus.innerHTML = `<span style="color:#ff6b6b">Need â‰¥ ${FBA_MIN} FBA to unlock</span>`;
    return false;
  }catch(e){
    console.error("Whitelist check failed", e);
    elFba.textContent = "Error";
    elStatus.innerHTML = `<span style="color:#ff6b6b">Error checking FBA</span>`;
    return false;
  }
}

/* ===== WinkLink oracle read (on-chain) ===== */
async function readOraclePriceUSD(oracleAddr){
  try{
    const c = await tronWebInstance.contract().at(oracleAddr);
    let od = 8;
    try{ const d = await c.decimals().call(); od = Number(d?.toString?.() ?? d ?? 8); }catch(_){}
    const ans = await c.latestAnswer().call();
    const raw = BigInt(ans?.toString?.() ?? ans ?? "0");
    if (raw <= 0n) return null;
    return Number(raw) / Math.pow(10, od);
  }catch(e){
    console.warn("oracle read failed", oracleAddr, e);
    return null;
  }
}

async function getPriceForToken(symbol, contract){
  if(contract && ORACLE_BY_CONTRACT[contract]) return await readOraclePriceUSD(ORACLE_BY_CONTRACT[contract]);
  if(symbol && ORACLE_BY_SYMBOL[symbol.toUpperCase()]) return await readOraclePriceUSD(ORACLE_BY_SYMBOL[symbol.toUpperCase()]);
  return null;
}

/* ===== Tronscan token list (discovery & fallback price) ===== */
async function fetchTronscanTokens(addr){
  try{
    const res = await fetch(TSCAN_TOKENS(addr));
    if(!res.ok) throw new Error("Tronscan HTTP " + res.status);
    const json = await res.json();
    // tronscan returns data: array in .data or .tokens
    const list = json?.data || json?.tokens || [];
    return list.map(t => {
      // Normalize fields from various shapes
      const contract = t.tokenId || t.tokenAddress || t.contract_address || t.contract || t.token_id || t.token_id_address || "";
      const decimals = Number(t.tokenDecimal ?? t.decimals ?? t.decimalsToken ?? t.decimal ?? 6);
      const balanceRaw = String(t.balance ?? t.amount ?? t.quantity ?? t.rawBalance ?? t.value ?? 0);
      // priceUsd fallback (Tronscan sometimes includes price info)
      const priceUsd = t.price_usd || t.price || t.usdPrice || null;
      return {
        symbol: t.tokenAbbr || t.symbol || t.tokenName || t.name || "UNKNOWN",
        name: t.tokenName || t.name || "",
        contract,
        decimals,
        balanceRaw,
        priceUsd
      };
    });
  }catch(e){
    console.warn("Tronscan tokens fetch failed for", addr, e);
    return [];
  }
}

/* ===== TRX balance ===== */
async function fetchTRX(addr){
  try{
    const sun = await tronWebInstance.trx.getBalance(addr);
    const sunBN = BigInt(typeof sun === "number" ? Math.trunc(sun) : String(sun));
    return toNumberFromRaw(sunBN, 6);
  }catch(e){ console.warn("TRX fetch error", addr, e); return 0; }
}

/* ===== TRC20 balance helper (on-chain) - optional use ===== */
async function fetchTRC20Balance(contractAddr, addr){
  try{
    const c = await tronWebInstance.contract().at(contractAddr);
    const raw = await c.balanceOf(addr).call();
    let dec = 6;
    try{ const d = await c.decimals().call(); dec = Number(d?.toString?.() ?? d ?? 6); }catch(_){}
    return { raw: BigInt(raw?.toString?.() ?? raw ?? "0"), decimals: dec };
  }catch(e){ console.warn("TRC20 read fail", contractAddr, e); return { raw: 0n, decimals:6 }; }
}

/* ===== Price resolution: oracle -> tronscan fallback ===== */
async function resolvePriceForToken(normalizedToken){
  // normalizedToken contains symbol, contract, decimals, priceUsd (fallback)
  const { symbol, contract, priceUsd } = normalizedToken;
  // 1) try oracle
  const p1 = await getPriceForToken(symbol, contract);
  if(p1 != null) return p1;
  // 2) try tronscan-provided price field (if present)
  if(priceUsd) {
    const v = Number(priceUsd);
    if(Number.isFinite(v) && v > 0) return v;
  }
  // 3) no price found
  return null;
}

/* ===== Main compute function ===== */
async function computeNetWorth(){
  if(!tronWebInstance || !tronWebInstance.defaultAddress) { alert("Connect TronLink first"); return; }

  const walletsRaw = (elWalletsText.value || "").split("\n").map(s => s.trim()).filter(Boolean);
  if(walletsRaw.length === 0) { alert("Paste at least one wallet address (one per line)"); return; }

  // build tokenContracts list from input
  const tokenContracts = (elTokenContractsInput.value || "").split(",").map(s=>s.trim()).filter(Boolean);

  elProgress.textContent = "Calculatingâ€¦";
  elProgress.innerHTML = 'Calculatingâ€¦ <span class="spinner"></span>';
  elGrand.textContent = "Grand Total: calculatingâ€¦";
  elUnpriced.textContent = "Discoveringâ€¦";

  let grandTotal = 0;
  const unpriced = [];
  const details = { wallets: {} };

  // price cache for oracle addresses
  const priceCache = {};

  async function getPriceCached(symbol, contract){
    // contract override
    if(contract && ORACLE_BY_CONTRACT[contract]) {
      const o = ORACLE_BY_CONTRACT[contract];
      if(priceCache[o] == null) priceCache[o] = await readOraclePriceUSD(o);
      return priceCache[o];
    }
    if(symbol && ORACLE_BY_SYMBOL[symbol.toUpperCase()]) {
      const o2 = ORACLE_BY_SYMBOL[symbol.toUpperCase()];
      if(priceCache[o2] == null) priceCache[o2] = await readOraclePriceUSD(o2);
      return priceCache[o2];
    }
    return null;
  }

  for(const addr of walletsRaw){
    details.wallets[addr] = { trx:0, tokens:[], unpriced:[] };
    // TRX
    const trx = await fetchTRX(addr);
    details.wallets[addr].trx = trx;
    const trxPrice = await getPriceCached("TRX", null);
    if(trxPrice != null){ grandTotal += trx * trxPrice; } else { details.wallets[addr].unpriced.push({symbol:"TRX", amount:trx}); unpriced.push({wallet:addr, symbol:"TRX", amount:trx}); }

    // Tronscan token list (fast discovery)
    const tokens = await fetchTronscanTokens(addr);
    for(const t of tokens){
      const decimals = Number(t.decimals ?? 6);
      const raw = BigInt(t.balanceRaw ?? "0");
      const units = toNumberFromRaw(raw, decimals);
      if(units <= 0) continue;
      // try resolve price
      const p = await resolvePriceForToken(t);
      if(p != null){
        grandTotal += units * p;
        details.wallets[addr].tokens.push({symbol:t.symbol, contract:t.contract, amount:units, usd: units * p});
      } else {
        // try optional on-chain TRC20 read + DEX fallback could be added (out of scope for this quick version)
        details.wallets[addr].unpriced.push({symbol:t.symbol, contract:t.contract, amount:units});
        unpriced.push({wallet:addr, symbol:t.symbol, contract:t.contract, amount:units});
      }
      // small delay for friendliness
      await sleep(40);
    }

    // additionally check any explicit token contracts the user put in (in case Tronscan missed or different formatting)
    for(const tc of tokenContracts){
      try{
        const b = await fetchTRC20Balance(tc, addr);
        const units = toNumberFromRaw(b.raw, b.decimals);
        if(units <= 0) continue;
        // try price by contract or symbol
        const price = await getPriceCached(null, tc) || await (async()=>{
          // try reading token symbol to map to oracle
          try{ const c = await tronWebInstance.contract().at(tc); const sym = await c.symbol().call().catch(()=>null); return sym? await getPriceCached(sym.toString(), tc):null; }catch(e){return null;}
        })();
        if(price != null){ grandTotal += units * price; details.wallets[addr].tokens.push({symbol:"(explicit)", contract:tc, amount:units, usd:units*price}); }
        else { details.wallets[addr].unpriced.push({symbol:"(explicit)", contract:tc, amount:units}); unpriced.push({wallet:addr, contract:tc, amount:units}); }
        await sleep(30);
      }catch(e){ console.warn("explicit token check failed", tc, e); }
    }
  } // end wallets loop

  elGrand.textContent = `Grand Total: ${fmtUSD(grandTotal)}`;
  if(unpriced.length) {
    elUnpriced.innerHTML = `Unpriced (${unpriced.length} items): ` + unpriced.slice(0,80).map(u => `${u.symbol||u.contract}(${u.amount})`).join(", ");
  } else {
    elUnpriced.textContent = "All discovered tokens priced (or none unpriced).";
  }
  elProgress.textContent = "Done";
  lastResult = { grandTotal, unpriced, details, timestamp: Date.now() };
  return lastResult;
}

/* ===== export / UI helpers ===== */
elBtnCalcNet.onclick = computeNetWorth;
elExport.onclick = ()=> {
  if(!lastResult) return alert("Run calculation first");
  const blob = new Blob([JSON.stringify(lastResult, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "defire-networth.json"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
};
elShowConsole.onclick = ()=> { console.log("Last result:", lastResult); alert("Result printed to console"); };

/* ===== FIRE calculator ===== */
document.getElementById("btnCalcFire").onclick = ()=> {
  const expenses = Number(document.getElementById("expenses").value);
  const current  = Number(document.getElementById("current").value);
  const yearly   = Number(document.getElementById("savings").value);
  const apyPct   = Number(document.getElementById("apy").value);
  if (![expenses, current, yearly, apyPct].every(x => Number.isFinite(x) && x >= 0)) {
    document.getElementById("fireResult").textContent = "Fill valid non-negative numbers.";
    return;
  }
  const r = apyPct/100;
  const target = expenses * 25;
  let bal = current;
  let years = 0;
  while(bal < target && years < 100){
    bal = bal * (1 + r) + yearly;
    years++;
  }
  if(years >= 100) {
    document.getElementById("fireOutput").innerHTML = `ðŸš« Not reached in 100 years. Target: $${target.toLocaleString()}`;
  } else {
    document.getElementById("fireOutput").innerHTML = `ðŸ”¥ Target: $${target.toLocaleString()} â€” Estimated time: <b>${years} years</b><br/>Projected balance: $${bal.toLocaleString(undefined,{maximumFractionDigits:2})}`;
  }
  document.getElementById("fireResult").textContent = "Done";
};

/* try auto-connect if TronLink injected */
window.addEventListener("load", ()=> setTimeout(()=> { if(window.tronWeb && window.tronWeb.ready) { elBtnConnect.click(); } }, 400) );

</script>
</body>
</html>
