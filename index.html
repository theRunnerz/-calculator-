<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ðŸ”¥ DeFire Dashboard v3 â€” FIRE + Full Net Worth (Tron)</title>
<script src="https://cdn.jsdelivr.net/npm/tronweb@5.3.0/dist/TronWeb.min.js"></script>
<style>
:root{--bg:#0a0a0a;--card:#0f1113;--accent:#ff6600;--muted:#9aa;--ok:#00ffc3}
body{font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(135deg,#0b0b0f,#1a0a00);color:#fff;margin:0;padding:18px;display:flex;justify-content:center}
.wrap{width:100%;max-width:1100px}
header{display:flex;align-items:center;justify-content:space-between;gap:12px}
h1{margin:0;font-size:1.25rem}
nav{display:flex;gap:8px}
button.tab{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:#fff;cursor:pointer}
.active{background:var(--accent);color:#000;border-color:var(--accent)}
.card{background:rgba(255,255,255,0.02);padding:14px;border-radius:12px;margin-top:14px;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
.row{display:flex;gap:10px;align-items:center;margin:8px 0;flex-wrap:wrap}
label{min-width:150px;opacity:.9}
textarea,input[type=text],input[type=number]{flex:1;padding:10px;border-radius:8px;border:none;background:#0f1113;color:#fff;min-width:0}
.pill{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-family:ui-monospace,monospace}
.small{font-size:.9rem;opacity:.85}
.addr{font-family:ui-monospace,monospace;color:#9fd8ff}
.spinner{width:16px;height:16px;border:3px solid rgba(255,255,255,0.12);border-top:3px solid var(--accent);border-radius:50%;animation:spin 1s linear infinite;display:inline-block;vertical-align:middle}
@keyframes spin{to{transform:rotate(360deg)}}
.total{font-size:1.25rem;font-weight:800;text-align:center;margin-top:12px}
pre.debug{background:#070707;padding:10px;border-radius:8px;max-height:360px;overflow:auto}
.modal{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:9999}
.modal .box{background:var(--card);padding:16px;border-radius:12px;width:100%;max-width:520px}
.smallbtn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:#fff;cursor:pointer;margin-left:6px}
table{width:100%;border-collapse:collapse;margin-top:8px}
th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>ðŸ”¥ DeFire Dashboard v3</h1>
      <div class="small" style="color:var(--muted)">FIRE calculator â€¢ Full net worth (frozen, JustLend, Sun.io, BTT, TRC20) â€¢ WinkLink + Tronscan + DEX</div>
    </div>
    <nav>
      <button id="tabFire" class="tab active">ðŸ”¥ FIRE</button>
      <button id="tabPortfolio" class="tab">ðŸ’° Portfolio</button>
    </nav>
  </header>

  <!-- CONNECT & WHITELIST -->
  <div class="card" id="connectCard">
    <div class="row"><label>Connected wallet</label><div class="pill addr" id="connected">Not connected</div></div>
    <div class="row"><label>FBA balance</label><div class="pill" id="fba">â€”</div></div>
    <div class="row"><label>Whitelist status</label><div class="pill" id="status">Connect TronLink to check</div></div>
    <div class="row">
      <button id="btnConnect">ðŸ”— Connect TronLink</button>
      <div style="margin-left:auto" class="small">Whitelist: owner OR â‰¥1000 FBA unlocks Portfolio</div>
    </div>
  </div>

  <!-- FIRE -->
  <div id="firePane" class="card">
    <h3 style="margin:0 0 8px">ðŸ”¥ FIRE Calculator</h3>
    <div class="row"><label>Yearly expenses (CAD)</label><input id="expenses" type="number" placeholder="e.g. 24000" /></div>
    <div class="row"><label>Current savings (CAD)</label><input id="current" type="number" placeholder="e.g. 116247" /></div>
    <div class="row"><label>Yearly savings (CAD)</label><input id="savings" type="number" placeholder="e.g. 24000" /></div>
    <div class="row"><label>Expected APY (%)</label><input id="apy" type="number" placeholder="e.g. 7" /></div>
    <div class="row">
      <button id="btnCalcFire">ðŸ”¥ Calculate FIRE</button>
      <div id="fireResult" class="pill">Idle</div>
    </div>
    <div id="fireOutput" style="margin-top:12px" class="small"></div>
  </div>

  <!-- PORTFOLIO -->
  <div id="portfolioPane" class="card" style="display:none">
    <h3 style="margin:0 0 8px">ðŸ’° Portfolio â€” Net Worth (full)</h3>

    <div class="row">
      <label>Wallets (one per line)</label>
      <textarea id="walletsText" placeholder="Paste TRON addresses (T...) one per line" rows="5"></textarea>
    </div>

    <div class="row">
      <label>Optional: token contracts (comma separated)</label>
      <input id="tokenContractsInput" placeholder="TUSDT...,TFBA...,T..." />
    </div>

    <div class="row">
      <label>Optional: JustLend comptroller or jToken list</label>
      <input id="justlendInput" placeholder="Comptroller or comma-separated jTokens" />
    </div>

    <div class="row">
      <button id="btnCalcNet">ðŸ§® Calculate Net Worth</button>
      <div id="progress" class="pill">Idle</div>
      <div style="margin-left:auto" class="small">Grand total shown in USD</div>
    </div>

    <div class="total" id="grand">Grand Total: â€”</div>

    <div style="margin-top:10px">
      <strong>Unpriced / Manual</strong>
      <div id="unpriced" class="small" style="margin-top:6px">No run yet</div>
    </div>

    <div style="margin-top:10px">
      <button id="btnExport" class="smallbtn">Export JSON</button>
      <button id="btnShowConsole" class="smallbtn">Show details (console)</button>
    </div>

    <h4 style="margin-top:12px">Debug / last run</h4>
    <pre id="debug" class="debug">No run yet.</pre>
  </div>

  <footer style="margin-top:14px" class="small">Client-side only â€” nothing leaves your browser except public API calls</footer>
</div>

<!-- Manual price modal -->
<div id="modal" class="modal">
  <div class="box">
    <h3 id="modalTitle">Set manual price</h3>
    <div class="row"><label>Token</label><div id="modalToken" class="pill">---</div></div>
    <div class="row"><label>Price (USD)</label><input id="modalPrice" type="number" step="0.0001" /></div>
    <div class="row">
      <button id="modalSave" class="smallbtn">Save</button>
      <button id="modalCancel" class="smallbtn">Cancel</button>
    </div>
  </div>
</div>

<script>
/* CONFIG â€” editable */
const OWNER_WALLET = "TY691Xr2EWgKJmHfm7NWKMRJjojLmS2cma";
const FBA_CONTRACT = "TNW5ABkp3v4jfeDo1vRVjxa3gtnoxP3DBN";
const FBA_MIN = 1000;

const ORACLE_BY_SYMBOL = {
  TRX: "TR5HtpPK4gX4RFC4DCBUHfFgsGkGFEzSAb",
  USDT: "TKePc46n5CiUCR8LL788TFeKA4kjvNnuem",
  USDC: "TNu3zS55MP4KnBBP6aw1nHSzRpc3CXAxm",
  SUN:  "TRMgzSPsuWEcVpd5hv19XtLeCk8Z799sZa",
  JST:  "TE5rKoDzKmpVAQp1sn7x6V8biivR3d5r47",
  BTT:  "TBAAW545oJ6iTxqzezVagrSUzCpz1S8eR",
  BTC:  "TQoijQ1iZKRgJsAAWNPMu6amgtCJ3WMUV7",
  ETH:  "TR2yWYWovJaSM7TfZq7L7sT7ZRugdJJQmL"
};
const ORACLE_BY_CONTRACT = {}; // add overrides if needed

const JUSTSWAP_FACTORY = "TXk8rQSAvPvBBNtqSoY6nCfsXWCSSpTVQF"; // community factory
const TSCAN_TOKENS = addr => `https://apilist.tronscanapi.com/api/account/tokens?address=${addr}&limit=500`;
const TSCAN_ACCOUNTV2 = addr => `https://apilist.tronscanapi.com/api/accountv2?address=${addr}`;
const JUSTLEND_ACCOUNT = addr => `https://api.just.network/api/v1/account?address=${addr}`;
const SUN_USER_INFO = addr => `https://api.sun.io/v3/user/info?address=${addr}`;
const BTT_INFO = addr => `https://apilist.tronscanapi.com/api/account/btt?address=${addr}`;
const BTT_BALANCE_BTTC = (addr, contract) => `https://api.bttcscan.com/api?module=account&action=tokenbalance&contractaddress=${contract}&address=${addr}`;

/* DOM refs */
const elConnected = document.getElementById("connected");
const elFba = document.getElementById("fba");
const elStatus = document.getElementById("status");
const elBtnConnect = document.getElementById("btnConnect");
const elTabFire = document.getElementById("tabFire");
const elTabPortfolio = document.getElementById("tabPortfolio");
const firePane = document.getElementById("firePane");
const portfolioPane = document.getElementById("portfolioPane");

const elBtnCalcFire = document.getElementById("btnCalcFire");
const elFireResult = document.getElementById("fireResult");
const elFireOutput = document.getElementById("fireOutput");

const elWalletsText = document.getElementById("walletsText");
const elTokenContractsInput = document.getElementById("tokenContractsInput");
const elJustlendInput = document.getElementById("justlendInput");
const elBtnCalcNet = document.getElementById("btnCalcNet");
const elProgress = document.getElementById("progress");
const elGrand = document.getElementById("grand");
const elUnpriced = document.getElementById("unpriced");
const elDebug = document.getElementById("debug");
const elBtnExport = document.getElementById("btnExport");
const elBtnShowConsole = document.getElementById("btnShowConsole");

const modal = document.getElementById("modal");
const modalToken = document.getElementById("modalToken");
const modalPrice = document.getElementById("modalPrice");
const modalSave = document.getElementById("modalSave");
const modalCancel = document.getElementById("modalCancel");

/* STATE */
let tronWebInstance = null;
let connectedAddr = "";
let oracleCache = {};
let manualPrices = JSON.parse(localStorage.getItem("defire_manualPrices")||"{}");
let lastResult = null;
let unlockedPortfolio = false;

const sleep = ms => new Promise(r=>setTimeout(r, ms));
function fmtUSD(n){ return Number(n||0).toLocaleString(undefined,{style:"currency",currency:"USD",maximumFractionDigits:2}); }
function toNumberFromRaw(rawBigInt, decimals){
  try{
    const scale = 10n ** BigInt(decimals);
    const intPart = rawBigInt / scale;
    const frac = rawBigInt % scale;
    let fracStr = frac.toString().padStart(decimals,"0");
    fracStr = fracStr.slice(0,8).replace(/0+$/,"");
    return Number(fracStr ? `${intPart.toString()}.${fracStr}` : `${intPart.toString()}`);
  }catch(e){ return 0; }
}

/* UI: tabs */
elTabFire.onclick = ()=>{ elTabFire.classList.add("active"); elTabPortfolio.classList.remove("active"); firePane.style.display="block"; portfolioPane.style.display="none"; };
elTabPortfolio.onclick = ()=>{ elTabPortfolio.classList.add("active"); elTabFire.classList.remove("active"); firePane.style.display="none"; portfolioPane.style.display="block"; };

/* Connect & whitelist */
elBtnConnect.onclick = async () => {
  if(!window.tronWeb || !window.tronWeb.ready){
    elStatus.innerHTML = '<span style="color:#ffd166">Open in TronLink & unlock</span>'; return;
  }
  tronWebInstance = window.tronWeb;
  connectedAddr = tronWebInstance.defaultAddress.base58 || "";
  elConnected.textContent = connectedAddr || "Unknown";
  elStatus.innerHTML = '<span class="small">Checking whitelistâ€¦ <span class="spinner"></span></span>';
  unlockedPortfolio = await checkWhitelist(connectedAddr);
  if(unlockedPortfolio){
    elStatus.innerHTML = `<span style="color:var(--ok)">Access granted</span>`;
    portfolioPane.style.display = "block";
  } else {
    elStatus.innerHTML = `<span style="color:#ff6b6b">Portfolio locked (need ${FBA_MIN} FBA or owner)</span>`;
    portfolioPane.style.display = "none";
  }
};

async function checkWhitelist(addr){
  try{
    if(!tronWebInstance) return false;
    if(addr === OWNER_WALLET){ elFba.textContent = "Owner"; return true; }
    const c = await tronWebInstance.contract().at(FBA_CONTRACT);
    const raw = await c.balanceOf(addr).call().catch(()=>0);
    let dec = 6; try{ const d = await c.decimals().call(); dec = Number(d?.toString?.() ?? d ?? 6); }catch(_){ dec = 6; }
    const bal = toNumberFromRaw(BigInt(raw?.toString?.() ?? raw ?? "0"), dec);
    elFba.textContent = `${bal.toLocaleString(undefined,{maximumFractionDigits:6})} FBA`;
    return bal >= FBA_MIN;
  }catch(e){
    console.error("Whitelist check failed", e);
    elFba.textContent = "Error";
    return false;
  }
}

/* ORACLE read (WinkLink) */
async function readOraclePriceUSD(oracleAddr){
  try{
    if(!tronWebInstance) return null;
    if(oracleCache[oracleAddr] != null) return oracleCache[oracleAddr];
    const c = await tronWebInstance.contract().at(oracleAddr);
    let od = 8; try{ const d = await c.decimals().call(); od = Number(d?.toString?.() ?? d ?? 8); }catch(_){}
    const ans = await c.latestAnswer().call();
    const raw = BigInt(ans?.toString?.() ?? ans ?? "0");
    if(raw <= 0n) { oracleCache[oracleAddr] = null; return null; }
    const val = Number(raw) / Math.pow(10, od);
    oracleCache[oracleAddr] = val;
    return val;
  }catch(e){ console.warn("oracle read failed", oracleAddr, e); return null; }
}

async function getPriceFromOracleOrManual(symbol, contract){
  if(contract && manualPrices[contract]) return manualPrices[contract];
  if(symbol && manualPrices[symbol.toUpperCase()]) return manualPrices[symbol.toUpperCase()];
  if(contract && ORACLE_BY_CONTRACT[contract]) {
    const o = ORACLE_BY_CONTRACT[contract];
    return await readOraclePriceUSD(o);
  }
  if(symbol && ORACLE_BY_SYMBOL[symbol.toUpperCase()]) {
    const o2 = ORACLE_BY_SYMBOL[symbol.toUpperCase()];
    return await readOraclePriceUSD(o2);
  }
  return null;
}

/* TronScan discovery & helpers */
async function fetchTronscanTokens(addr){
  try{
    const res = await fetch(TSCAN_TOKENS(addr));
    if(!res.ok) throw new Error("Tronscan HTTP " + res.status);
    const json = await res.json();
    const list = json?.data || json?.tokens || [];
    return list.map(t=>{
      const contract = t.tokenId || t.tokenAddress || t.contract_address || t.contract || t.token_id || t.address || "";
      const decimals = Number(t.tokenDecimal ?? t.decimals ?? t.decimalsToken ?? t.decimal ?? 6);
      const balanceRaw = t.balance ?? t.amount ?? t.quantity ?? t.value ?? t.rawBalance ?? null;
      let units = 0;
      if(balanceRaw === null || balanceRaw === undefined) units = 0;
      else {
        const s = String(balanceRaw);
        if(s.includes(".") || s.toLowerCase().includes("e")) units = Number(parseFloat(s) || 0);
        else { try { units = toNumberFromRaw(BigInt(s), decimals); } catch(e){ units = Number(s) / Math.pow(10, decimals); } }
      }
      const priceUsd = t.price_usd ?? t.price ?? t.usdPrice ?? null;
      const symbol = t.tokenAbbr ?? t.symbol ?? t.tokenName ?? t.name ?? "UNKNOWN";
      return { symbol, name: t.tokenName || t.name || "", contract, decimals, units, priceUsd };
    });
  }catch(e){ console.warn("Tronscan tokens fetch failed for", addr, e); return []; }
}

/* fetch TRX native */
async function fetchTRX(addr){
  try{
    const sun = await tronWebInstance.trx.getBalance(addr);
    const sunBN = BigInt(typeof sun === "number" ? Math.trunc(sun) : String(sun));
    return toNumberFromRaw(sunBN, 6);
  }catch(e){ console.warn("TRX fetch error", addr, e); return 0; }
}

/* TRC20 read fallback */
async function fetchTRC20Balance(contractAddr, addr){
  try{
    const c = await tronWebInstance.contract().at(contractAddr);
    const raw = await c.balanceOf(addr).call();
    let dec = 6; try{ const d = await c.decimals().call(); dec = Number(d?.toString?.() ?? d ?? 6); }catch(_){}
    return { raw: BigInt(raw?.toString?.() ?? raw ?? "0"), decimals: dec, units: toNumberFromRaw(BigInt(raw?.toString?.() ?? raw ?? "0"), dec) };
  }catch(e){ console.warn("TRC20 read fail", contractAddr, e); return { raw: 0n, decimals: 6, units: 0 }; }
}

/* JustSwap DEX fallback */
async function findJustSwapExchangeForToken(tokenContract){
  try{
    const factory = await tronWebInstance.contract().at(JUSTSWAP_FACTORY);
    try { const ex = await factory.getExchange(tokenContract).call(); if(ex && ex !== "0x0000000000000000000000000000000000000000") return ex; } catch(_) {}
    try { const ex2 = await factory.getPair(tokenContract, tokenContract).call(); if(ex2) return ex2; } catch(_) {}
  }catch(e){ /* ignore */ }
  return null;
}
async function readJustSwapPriceForToken(tokenContract){
  try{
    const exchange = await findJustSwapExchangeForToken(tokenContract);
    if(!exchange) return null;
    const trxBalanceSun = await tronWebInstance.trx.getBalance(exchange).catch(()=>0);
    const trxBalance = toNumberFromRaw(BigInt(typeof trxBalanceSun === "number" ? Math.trunc(trxBalanceSun) : String(trxBalanceSun)), 6);
    const tokenC = await tronWebInstance.contract().at(tokenContract);
    const raw = await tokenC.balanceOf(exchange).call();
    const dec = Number(await tokenC.decimals().call().catch(()=>6));
    const tokenBalance = toNumberFromRaw(BigInt(raw?.toString?.() ?? raw ?? "0"), dec);
    if(tokenBalance <= 0 || trxBalance <= 0) return null;
    const trxUsd = await getTrxUsd();
    if(!trxUsd) return null;
    const priceUsd = (trxBalance * trxUsd) / tokenBalance;
    if(!isFinite(priceUsd) || priceUsd <= 0 || priceUsd > 1e12) return null;
    return priceUsd;
  }catch(e){ return null; }
}

/* TRX USD helper */
async function getTrxUsd(){
  const oracle = ORACLE_BY_SYMBOL.TRX;
  if(!oracle) return null;
  if(oracleCache[oracle] != null) return oracleCache[oracle];
  const v = await readOraclePriceUSD(oracle);
  oracleCache[oracle] = v;
  return v;
}

/* EXTRA SOURCES: frozen / justlend / sun.io / btt */
async function fetchFrozenInfo(addr){
  try{
    const res = await fetch(TSCAN_ACCOUNTV2(addr));
    if(!res.ok) throw new Error("accountv2 HTTP " + res.status);
    const json = await res.json();
    let totalFrozen = 0;
    if(typeof json?.frozen_total_amount === "number") totalFrozen = json.frozen_total_amount;
    else if(typeof json?.frozenTotalAmount === "number") totalFrozen = json.frozenTotalAmount;
    else if(json?.frozen && Array.isArray(json.frozen)){
      for(const f of json.frozen) if(f?.amount) totalFrozen += Number(f.amount);
    }
    // tronscan sometimes returns SUN amounts â€” normalize heuristically
    if(totalFrozen > 1e9) totalFrozen = totalFrozen / 1e6;
    return { totalFrozen };
  }catch(e){ console.warn("fetchFrozenInfo failed", e); return { totalFrozen: 0 }; }
}

async function fetchJustLendAccount(addr){
  try{
    const res = await fetch(JUSTLEND_ACCOUNT(addr));
    if(!res.ok) throw new Error("JustLend HTTP " + res.status);
    const json = await res.json();
    return json;
  }catch(e){ console.warn("JustLend API failed", e); return null; }
}

async function fetchSunUser(addr){
  try{
    const res = await fetch(SUN_USER_INFO(addr));
    if(!res.ok) throw new Error("Sun API HTTP " + res.status);
    const json = await res.json();
    return json;
  }catch(e){ console.warn("Sun API fetch failed", e); return null; }
}

async function fetchBttInfo(addr){
  try{
    const res = await fetch(BTT_INFO(addr));
    if(!res.ok) throw new Error("BTT HTTP " + res.status);
    const json = await res.json();
    return json;
  }catch(e){ console.warn("BTT fetch failed", e); return null; }
}

/* Bttt cchain token read helper (BTTC chain API example) â€” requires known contract */
async function fetchBttBalanceBttc(addr, contract){
  try{
    const res = await fetch(BTT_BALANCE_BTTC(addr, contract));
    if(!res.ok) throw new Error("BTTC API HTTP " + res.status);
    const json = await res.json();
    if(json?.status === "1" && json?.result) return Number(json.result || 0);
    return 0;
  }catch(e){ console.warn("BTTC fetch failed", e); return 0; }
}

/* MAIN: compute net worth (full integration) */
async function computeNetWorth(){
  if(!tronWebInstance || !tronWebInstance.defaultAddress) { alert("Connect TronLink and unlock first"); return; }
  const walletsRaw = (elWalletsText.value || "").split("\n").map(s=>s.trim()).filter(Boolean);
  const wallets = walletsRaw.length ? walletsRaw : [connectedAddr];
  if(wallets.length === 0) { alert("No wallets to check"); return; }

  const tokenContracts = (elTokenContractsInput.value || "").split(",").map(s=>s.trim()).filter(Boolean);
  const jlInput = (elJustlendInput.value || "").trim();

  elProgress.textContent = "Calculatingâ€¦"; elProgress.innerHTML = 'Calculatingâ€¦ <span class="spinner"></span>';
  elGrand.textContent = "Grand Total: calculatingâ€¦";
  elUnpriced.textContent = "Discoveringâ€¦";
  elDebug.textContent = "Runningâ€¦";

  let grandTotal = 0;
  const unpriced = [];
  const details = { wallets: {} };
  const trxUsd = await getTrxUsd();

  for(const w of wallets){
    details.wallets[w] = { trx:0, trxUsd:0, frozen:0, tokens:[], lending:[], sun:null, btt:null, unpriced:[] };

    // 1) TRX native
    let trxUnits = 0;
    try { trxUnits = await fetchTRX(w); } catch(e){ trxUnits = 0; }
    details.wallets[w].trx = trxUnits;
    if(trxUsd){ const v = trxUnits * trxUsd; details.wallets[w].trxUsd = v; grandTotal += v; }

    // 2) frozen TRX
    try{
      const f = await fetchFrozenInfo(w);
      details.wallets[w].frozen = f.totalFrozen || 0;
      if(details.wallets[w].frozen > 0){
        if(trxUsd){ const fv = details.wallets[w].frozen * trxUsd; details.wallets[w].frozenUsd = fv; grandTotal += fv; }
        else details.wallets[w].frozenUsd = null;
      }
    }catch(e){ details.wallets[w].frozen = 0; }

    // 3) Tronscan tokens
    try{
      const tokens = await fetchTronscanTokens(w);
      for(const t of tokens){
        if(!t.contract){ details.wallets[w].unpriced.push({symbol:t.symbol, amount:t.units}); unpriced.push({wallet:w, symbol:t.symbol, amount:t.units}); continue; }
        const units = Number(t.units || 0);
        if(units <= 0) continue;
        // price resolution
        let price = await getPriceFromOracleOrManual(t.symbol, t.contract);
        let priceSource = null;
        if(price != null) priceSource = "oracle";
        else if(t.priceUsd){ const p = Number(t.priceUsd); if(Number.isFinite(p) && p>0){ price = p; priceSource = "tronscan"; } }
        else {
          const dex = await readJustSwapPriceForToken(t.contract);
          if(dex != null){ price = dex; priceSource = "justswap"; }
        }
        if(price != null){
          const usdVal = units * price; details.wallets[w].tokens.push({ symbol:t.symbol, contract:t.contract, amount:units, usd:usdVal, priceSource }); grandTotal += usdVal;
        } else {
          details.wallets[w].unpriced.push({ symbol:t.symbol, contract:t.contract, amount:units });
          unpriced.push({ wallet:w, symbol:t.symbol, contract:t.contract, amount:units });
        }
        await sleep(20);
      }
    }catch(e){ console.warn("tokens loop error", e); }

    // 4) explicit token contracts (user)
    for(const tc of tokenContracts){
      try{
        const b = await fetchTRC20Balance(tc, w);
        const units = Number(b.units || 0);
        if(units <= 0) continue;
        let price = await getPriceFromOracleOrManual(null, tc);
        if(!price){
          try{ const c = await tronWebInstance.contract().at(tc); const sym = await c.symbol().call().catch(()=>null); if(sym) price = await getPriceFromOracleOrManual(sym.toString(), tc); } catch(_) {}
        }
        if(!price){ const dex = await readJustSwapPriceForToken(tc); if(dex) price = dex; }
        if(price != null){ const usdVal = units * price; details.wallets[w].tokens.push({symbol:"(explicit)", contract:tc, amount:units, usd:usdVal}); grandTotal += usdVal; } 
        else { details.wallets[w].unpriced.push({ contract:tc, amount:units }); unpriced.push({ wallet:w, contract:tc, amount:units }); }
      }catch(e){ console.warn("explicit token fail", e); }
      await sleep(20);
    }

    // 5) JustLend: public API
    try{
      const jl = await fetchJustLendAccount(w);
      if(jl){
        // prefer API USD totals if provided
        if(typeof jl.account?.totalSupplyUsd === "number"){ // some APIs name these differently
          const sUsd = jl.account.totalSupplyUsd || jl.account.supplyUsd || jl.account.totalSupplyUsd;
          const bUsd = jl.account.totalBorrowUsd || jl.account.borrowUsd || 0;
          const net = (Number(sUsd||0) - Number(bUsd||0));
          if(!isNaN(net) && net !== 0){ details.wallets[w].lending.push({ source:"justlend-api", usd: net, raw: jl }); grandTotal += net; }
        } else if(typeof jl.totalUsd === "number"){
          details.wallets[w].lending.push({ source:"justlend-api", usd: Number(jl.totalUsd), raw: jl }); grandTotal += Number(jl.totalUsd);
        } else if(Array.isArray(jl.supplies) || Array.isArray(jl?.assets)){
          // try to parse supplies array
          const supplies = jl.supplies || jl.assets || [];
          for(const s of supplies){
            let amt = Number(s.amount || s.units || s.underlyingAmount || 0);
            let usdVal = s.usdValue || s.usd || s.valueUsd || null;
            if(!usdVal && s.underlying){
              const p = await getPriceFromOracleOrManual(s.symbol || null, s.underlying);
              if(p != null) usdVal = amt * p;
              else {
                const dexP = await readJustSwapPriceForToken(s.underlying).catch(()=>null);
                if(dexP) usdVal = amt * dexP;
              }
            }
            if(usdVal != null){ details.wallets[w].lending.push({ source:"justlend", underlying:s.underlying, amount:amt, usd:usdVal }); grandTotal += usdVal; }
            else { details.wallets[w].unpriced.push({source:"justlend", underlying:s.underlying, amount:amt}); unpriced.push({wallet:w, source:"justlend", underlying:s.underlying, amount:amt}); }
          }
        }
      }
    }catch(e){ console.warn("JustLend fetch error", e); }

    // 6) Sun.io user info
    try{
      const sun = await fetchSunUser(w);
      if(sun){
        if(typeof sun.totalUsd === "number"){ details.wallets[w].sun = { usd: sun.totalUsd, raw: sun }; grandTotal += Number(sun.totalUsd); }
        else if(Array.isArray(sun?.lpList) && sun.lpList.length){
          for(const lp of sun.lpList){
            if(typeof lp.usdValue === "number"){ details.wallets[w].sun = details.wallets[w].sun || { usd:0 }; details.wallets[w].sun.usd = (details.wallets[w].sun.usd||0) + Number(lp.usdValue); grandTotal += Number(lp.usdValue); }
            else { details.wallets[w].unpriced.push({source:"sun", lp}); unpriced.push({wallet:w, source:"sun", lp}); }
          }
        }
      }
    }catch(e){ console.warn("Sun fetch error", e); }

    // 7) BTT info (Tronscan extension)
    try{
      const btt = await fetchBttInfo(w);
      if(btt){
        if(typeof btt.totalUsd === "number"){ details.wallets[w].btt = { usd: btt.totalUsd }; grandTotal += btt.totalUsd; }
        else if(btt?.tokens && Array.isArray(btt.tokens)){
          for(const t of btt.tokens){
            if(t?.symbol && t.symbol.toUpperCase().includes("BTT") && t.amount){
              const price = await getPriceFromOracleOrManual("BTT", null) || Number(t.priceUsd || 0);
              if(price){ const usdVal = Number(t.amount) * price; details.wallets[w].btt = details.wallets[w].btt || { usd:0 }; details.wallets[w].btt.usd = (details.wallets[w].btt.usd||0) + usdVal; grandTotal += usdVal; }
              else { details.wallets[w].unpriced.push({source:"btt", token:t}); unpriced.push({wallet:w, source:"btt", token:t}); }
            }
          }
        }
      }
    }catch(e){ console.warn("BTT fetch error", e); }

    // slight pause per wallet
    await sleep(80);
  } // end wallets loop

  // finalize UI
  elGrand.textContent = `Grand Total: ${fmtUSD(grandTotal)}`;
  elProgress.textContent = "Done";
  if(unpriced.length){
    elUnpriced.innerHTML = unpriced.slice(0,200).map((u, i) => {
      const label = u.symbol || u.contract || u.underlying || u.lp || u.source || "unknown";
      return `<div style="margin:6px 0"><a href="#" class="unpriced-link" data-contract="${u.contract||u.underlying||''}" data-symbol="${u.symbol||''}" data-idx="${i}">${label}</a> â€” ${u.amount||''}</div>`;
    }).join("");
    document.querySelectorAll(".unpriced-link").forEach(a=>{
      a.onclick = (ev)=>{ ev.preventDefault(); const contract = a.getAttribute("data-contract"); const symbol = a.getAttribute("data-symbol"); openManualPriceModal(symbol || contract, contract || symbol); };
    });
  } else { elUnpriced.textContent = "No unpriced items"; }
  elDebug.textContent = JSON.stringify(details, null, 2);
  lastResult = { grandTotal, details, unpriced, timestamp: Date.now() };
  localStorage.setItem("defire_manualPrices", JSON.stringify(manualPrices || {}));
  console.log("DeFire result:", lastResult);
  return lastResult;
}

/* Manual price modal */
function openManualPriceModal(tokenLabel, contractOrSymbol){
  modal.style.display = "flex"; modalToken.textContent = tokenLabel || contractOrSymbol || "token"; modalPrice.value = manualPrices[contractOrSymbol] ?? "";
  modalSave.onclick = ()=> {
    const v = Number(modalPrice.value);
    if(!Number.isFinite(v) || v <= 0){ alert("Enter valid price > 0"); return; }
    manualPrices[contractOrSymbol] = v;
    modal.style.display = "none";
    localStorage.setItem("defire_manualPrices", JSON.stringify(manualPrices || {}));
    if(lastResult) computeNetWorth();
  };
  modalCancel.onclick = ()=> { modal.style.display = "none"; };
}

/* FIRE calculator */
elBtnCalcFire.onclick = ()=> {
  const expenses = Number(document.getElementById("expenses").value);
  const current  = Number(document.getElementById("current").value);
  const yearly   = Number(document.getElementById("savings").value);
  const apyPct   = Number(document.getElementById("apy").value);
  if (![expenses, current, yearly, apyPct].every(x => Number.isFinite(x) && x >= 0)) {
    elFireResult.textContent = "Fill valid non-negative numbers.";
    return;
  }
  const r = apyPct/100;
  const target = expenses * 25;
  let bal = current;
  let years = 0;
  while(bal < target && years < 100){
    bal = bal * (1 + r) + yearly;
    years++;
  }
  if(years >= 100) elFireOutput.innerHTML = `ðŸš« Not reached in 100 years. Target: $${target.toLocaleString()}`;
  else elFireOutput.innerHTML = `ðŸ”¥ Target: $${target.toLocaleString()} â€” Estimated time: <b>${years} years</b><br/>Projected balance: $${bal.toLocaleString(undefined,{maximumFractionDigits:2})}`;
  elFireResult.textContent = "Done";
};

/* Bind compute */
elBtnCalcNet.onclick = computeNetWorth;
elBtnExport.onclick = ()=> {
  if(!lastResult) return alert("Run calculation first");
  const blob = new Blob([JSON.stringify(lastResult, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "defire-networth.json"; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
};
elBtnShowConsole.onclick = ()=> { console.log("Last result:", lastResult); alert("Result printed to console"); };

/* Auto-connect if TronLink injected/unlocked */
window.addEventListener("load", ()=> setTimeout(()=> { if(window.tronWeb && window.tronWeb.ready) { elBtnConnect.click(); } }, 400) );
</script>
</body>
</html>
