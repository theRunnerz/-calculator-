<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DeFire â€” On-Chain Net Worth (DEX fallback + meta enrichment)</title>
  <script src="https://cdn.jsdelivr.net/npm/tronweb@5.3.0/dist/TronWeb.min.js"></script>
  <style>
    :root{--bg:#0b0b0f;--accent:#ff6600}
    body{font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(135deg,#0b0b0f,#1a0a00);color:#fff;margin:0;padding:18px;display:flex;justify-content:center}
    .wrap{width:100%;max-width:1000px}
    .card{background:rgba(255,255,255,0.02);border-radius:10px;padding:14px;margin-top:12px}
    textarea,input{width:100%;padding:10px;border-radius:8px;border:none;background:#0f1113;color:#fff;margin-top:6px}
    button{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:#000;font-weight:700;cursor:pointer}
    .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03)}
    .muted{opacity:.8}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    th,td{padding:8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left}
    .small{font-size:.9rem;opacity:.85}
    pre.debug{background:#0a0a0a;padding:8px;border-radius:6px;max-height:320px;overflow:auto}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸ”¥ DeFire â€” Net Worth (DEX fallback & token metadata enrichment)</h1>

    <div class="card">
      <div class="small muted">Open in TronLink. Paste one TRON address per line. Optional: add explicit token contracts or JustLend comptroller/jTokens.</div>

      <div style="margin-top:10px">
        <label><strong>Wallets (one per line)</strong></label>
        <textarea id="walletsText" rows="6" placeholder="T... (one per line)"></textarea>
      </div>

      <div style="margin-top:10px">
        <label><strong>Optional: token contracts (comma separated)</strong></label>
        <input id="tokenContractsInput" placeholder="TUSDT..., TFBA..., ..." />
      </div>

      <div style="margin-top:10px">
        <label><strong>Optional: JustLend comptroller or jTokens</strong></label>
        <input id="justlendInput" placeholder="Comptroller or comma-separated jTokens" />
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;align-items:center">
        <button id="btnCalc">ðŸ§® Calculate Net Worth</button>
        <div id="status" class="pill">Idle</div>
        <div id="trxPrice" class="pill">TRX $â€”</div>
      </div>

      <div style="margin-top:14px">
        <div><strong id="grand">Grand Total: â€”</strong></div>
        <div id="perWallet" class="small muted" style="margin-top:8px"></div>
      </div>

      <h4 style="margin-top:12px">Unpriced / manual (click to set price)</h4>
      <div id="unpriced" class="small muted">â€”</div>

      <h4 style="margin-top:12px">Debug / last run</h4>
      <pre id="debug" class="debug">No run yet.</pre>
    </div>
  </div>

<script>
/* CONFIG */
const JUSTSWAP_FACTORY = "TXk8rQSAvPvBBNtqSoY6nCfsXWCSSpTVQF"; // common community factory (change if you use another)
const ORACLE_BY_SYMBOL = {
  TRX: "TR5HtpPK4gX4RFC4DCBUHfFgsGkGFEzSAb",
  USDT: "TKePc46n5CiUCR8LL788TFeKA4kjvNnuem",
  USDC: "TNu3zS55MP4KnBBP6aw1nHSzRpc3CXAxm",
  BTT:  "TBAAW545oJ6iTxqzezVagrSUzCpz1S8eR",
  SUN:  "TRMgzSPsuWEcVpd5hv19XtLeCk8Z799sZa"
};
const TSCAN_TOKENS = addr => `https://apilist.tronscanapi.com/api/account/tokens?address=${addr}&limit=500`;

/* DOM */
const elWalletsText = document.getElementById("walletsText");
const elTokenContractsInput = document.getElementById("tokenContractsInput");
const elJustlendInput = document.getElementById("justlendInput");
const elBtnCalc = document.getElementById("btnCalc");
const elStatus = document.getElementById("status");
const elGrand = document.getElementById("grand");
const elPerWallet = document.getElementById("perWallet");
const elDebug = document.getElementById("debug");
const elTrxPrice = document.getElementById("trxPrice");
const elUnpriced = document.getElementById("unpriced");

let tronWebInstance = null;
let trxUsdCache = null;
let manualPrices = {}; // user can set this via clicking unpriced entries (not included UI here but we expose state)
let lastResult = null;

const sleep = ms => new Promise(r => setTimeout(r, ms));
function fmtUSD(n){ return Number(n||0).toLocaleString(undefined,{style:"currency",currency:"USD",maximumFractionDigits:2}); }
function toNumberFromRaw(rawBigInt, decimals){
  try{
    const scale = 10n ** BigInt(decimals);
    const intPart = rawBigInt / scale;
    const fracPart = rawBigInt % scale;
    let fracStr = fracPart.toString().padStart(decimals, "0").replace(/0+$/,"");
    const asStr = fracStr ? `${intPart.toString()}.${fracStr.slice(0,8)}` : `${intPart.toString()}`;
    return Number(asStr);
  }catch(e){ return 0; }
}

/* Oracle read */
async function readOraclePriceUSD(oracleAddr){
  try{
    const c = await tronWebInstance.contract().at(oracleAddr);
    let od = 8;
    try{ const d = await c.decimals().call(); od = Number(d?.toString?.() ?? d ?? 8); }catch(_){}
    const ans = await c.latestAnswer().call();
    const raw = BigInt(ans?.toString?.() ?? ans ?? "0");
    if(raw <= 0n) return null;
    return Number(raw) / Math.pow(10, od);
  }catch(e){ console.warn("oracle read failed", oracleAddr, e); return null; }
}
async function getTrxUsd(){
  if(trxUsdCache != null) return trxUsdCache;
  const oracle = ORACLE_BY_SYMBOL.TRX;
  if(!oracle) return null;
  trxUsdCache = await readOraclePriceUSD(oracle);
  return trxUsdCache;
}

/* Tronscan token discovery + normalization */
function normalizeTronscanToken(t){
  const contract = t.tokenId || t.tokenAddress || t.contract_address || t.contract || t.token_id || t.address || t.contractAddress || "";
  const decimals = Number(t.tokenDecimal ?? t.decimals ?? t.decimalsToken ?? t.decimal ?? 6);
  const balanceRaw = t.balance ?? t.amount ?? t.quantity ?? t.value ?? t.rawBalance ?? null;
  let units = 0;
  if(balanceRaw === null || balanceRaw === undefined) units = 0;
  else {
    const s = String(balanceRaw);
    if (s.includes(".") || s.toLowerCase().includes("e")) units = Number(parseFloat(s) || 0);
    else {
      try { units = toNumberFromRaw(BigInt(s), decimals); } catch(e) { units = Number(s) / Math.pow(10, decimals); }
    }
  }
  const priceUsd = t.price_usd ?? t.price ?? t.usdPrice ?? null;
  const symbol = t.tokenAbbr ?? t.symbol ?? t.tokenName ?? t.name ?? "UNKNOWN";
  return { symbol, name: t.tokenName || t.name || "", contract, decimals, units, priceUsd };
}
async function fetchTronscanTokens(addr){
  try{
    const res = await fetch(TSCAN_TOKENS(addr));
    if(!res.ok) throw new Error("Tronscan HTTP " + res.status);
    const json = await res.json();
    const list = json?.data || json?.tokens || [];
    return list.map(normalizeTronscanToken);
  }catch(e){ console.warn("Tronscan request failed", e); return []; }
}

/* On-chain token metadata enrichment: symbol(), decimals() */
async function enrichTokenMetadata(token){
  // token: { symbol, contract, decimals, units }
  try{
    if(!token.contract) return token;
    const c = await tronWebInstance.contract().at(token.contract);
    try { const sym = await c.symbol().call(); if(sym) token.symbol = sym.toString(); } catch(_) {}
    try { const d = await c.decimals().call(); token.decimals = Number(d?.toString?.() ?? d ?? token.decimals ?? 6); } catch(_) {}
    // If units looks tiny or suspicious, re-read balanceOf on-chain and compute units using decimals
    try {
      const bal = await c.balanceOf(token._owner || token._queriedOwner || token.owner || token._lastOwner || token.queryOwner).call().catch(()=>null);
      // we don't call balanceOf generically here to avoid extra calls unless needed
    } catch(_) {}
    return token;
  } catch(e){ return token; }
}

/* Fallback DEX (JustSwap) price attempt:
   - Use factory.getExchange(token) (common) to get exchange address
   - Read TRX balance of exchange (via tronWeb.trx.getBalance)
   - Read token.balanceOf(exchange)
   - price = (trx_balance * trx_usd) / token_balance
*/
async function findJustSwapExchange(tokenContract){
  try{
    if(!JUSTSWAP_FACTORY) return null;
    const factory = await tronWebInstance.contract().at(JUSTSWAP_FACTORY);
    // try getExchange(token)
    try {
      const ex = await factory.getExchange(tokenContract).call();
      if(ex && ex !== "0x0000000000000000000000000000000000000000") return ex;
    } catch(_) {}
    // some factories use getPair or getExchangeAddress
    try {
      if(typeof factory.getPair === "function") {
        const ex2 = await factory.getPair(tokenContract, tokenContract).call().catch(()=>null);
        if(ex2) return ex2;
      }
    } catch(_) {}
    return null;
  } catch(e) { console.warn("findJustSwapExchange failed", e); return null; }
}

async function readJustSwapPriceForToken(tokenContract){
  try{
    const exchange = await findJustSwapExchange(tokenContract);
    if(!exchange) return null;
    // get TRX balance of exchange
    const trxBalanceRaw = await tronWebInstance.trx.getBalance(exchange).catch(()=>0);
    const trxBalance = toNumberFromRaw(BigInt(typeof trxBalanceRaw === "number" ? Math.trunc(trxBalanceRaw) : String(trxBalanceRaw)), 6);
    // get token balance of exchange
    try {
      const tokenC = await tronWebInstance.contract().at(tokenContract);
      const raw = await tokenC.balanceOf(exchange).call();
      const dec = Number(await tokenC.decimals().call().catch(()=>6));
      const tokenBalance = toNumberFromRaw(BigInt(raw?.toString?.() ?? raw ?? "0"), dec);
      if(tokenBalance <= 0 || trxBalance <= 0) return null;
      const trxUsd = await getTrxUsd();
      if(!trxUsd) return null;
      const priceUsd = (trxBalance * trxUsd) / tokenBalance;
      // ignore ridiculously small or huge prices as garbage
      if(!isFinite(priceUsd) || priceUsd <= 0 || priceUsd > 1e12) return null;
      return priceUsd;
    } catch(e) {
      console.warn("readJustSwapPriceForToken token read failed", e);
      return null;
    }
  }catch(e){
    console.warn("JustSwap fallback failed", e);
    return null;
  }
}

/* Resolve price for token with chain-first approach:
   1) Manual override
   2) Oracle by contract or symbol (ORACLE_BY_SYMBOL not exhaustive)
   3) Tronscan price_usd
   4) JustSwap DEX fallback (TRX pair -> USD)
*/
async function resolvePriceUsd(token){
  // token: {symbol, contract, decimals, units, priceUsd}
  if(token.contract && manualPrices[token.contract]) return { price: manualPrices[token.contract], source: "manual(contract)" };
  if(token.symbol && manualPrices[token.symbol.toUpperCase()]) return { price: manualPrices[token.symbol.toUpperCase()], source: "manual(symbol)" };

  // try oracle by symbol
  if(token.symbol && ORACLE_BY_SYMBOL[token.symbol.toUpperCase()]) {
    const p = await readOraclePriceUSD(ORACLE_BY_SYMBOL[token.symbol.toUpperCase()]);
    if(p != null) return { price: p, source: "oracle(symbol)" };
  }
  // tronscan price
  if(token.priceUsd) {
    const num = Number(token.priceUsd);
    if(Number.isFinite(num) && num > 0) return { price: num, source: "tronscan" };
  }
  // DEX fallback (on-chain)
  if(token.contract){
    const dexPrice = await readJustSwapPriceForToken(token.contract);
    if(dexPrice != null) return { price: dexPrice, source: "justswap" };
  }
  return null;
}

/* Main compute function */
async function computeNetWorth(){
  if(!window.tronWeb || !window.tronWeb.ready) { alert("Open the page in TronLink (in-app) or unlock TronLink extension"); return; }
  tronWebInstance = window.tronWeb;
  trxUsdCache = null;
  elStatus.textContent = "Runningâ€¦";
  elDebug.textContent = "Starting run...\n";
  const debugLines = [];

  const wallets = (elWalletsText.value || "").split("\n").map(s=>s.trim()).filter(Boolean);
  if(wallets.length === 0) { alert("Paste at least one wallet (one per line)"); return; }
  const explicitContracts = (elTokenContractsInput.value || "").split(",").map(s=>s.trim()).filter(Boolean);
  const jlInput = (elJustlendInput.value || "").trim();

  const trxUsd = await getTrxUsd();
  elTrxPrice.textContent = `TRX ${trxUsd ? fmtUSD(trxUsd) : "â€”"}`;
  debugLines.push(`TRX USD price: ${trxUsd}`);

  let grandTotal = 0;
  const perWalletTotals = {};
  const unpriced = [];

  // If JustLend input is comptroller, try discover markets (best-effort)
  let jlMarkets = [];
  if(jlInput){
    if(jlInput.includes(",")) jlMarkets = jlInput.split(",").map(s=>s.trim()).filter(Boolean);
    else {
      try {
        jlMarkets = await (async (addr)=>{ const comp = await tronWebInstance.contract().at(addr); try { const mk = await comp.getAllMarkets().call(); return mk.map(m=>m.toString ? m.toString() : m); } catch(e){ return []; } })(jlInput);
        debugLines.push(`JustLend discovery found ${jlMarkets.length}`);
      } catch(e){ debugLines.push("JustLend discovery error"); }
    }
  }

  for(const addr of wallets){
    debugLines.push(`--- Wallet ${addr} ---`);
    perWalletTotals[addr] = { subtotal: 0, items: [] };

    // TRX native
    let trxUnits = 0;
    try {
      const sun = await tronWebInstance.trx.getBalance(addr);
      trxUnits = toNumberFromRaw(BigInt(typeof sun === "number" ? Math.trunc(sun) : String(sun)), 6);
    } catch(e){ console.warn("TRX getBalance failed", e); }
    if(trxUsd) {
      const val = trxUnits * trxUsd; grandTotal += val; perWalletTotals[addr].subtotal += val;
      perWalletTotals[addr].items.push({ symbol: "TRX", amount: trxUnits, usd: val, source: "native" });
      debugLines.push(`TRX: ${trxUnits} => ${fmtUSD(val)}`);
    } else {
      perWalletTotals[addr].items.push({ symbol: "TRX", amount: trxUnits, usd: null, source: "native" });
      debugLines.push(`TRX: ${trxUnits} => price missing`);
    }

    // Tronscan tokens discovery
    const tokens = await fetchTronscanTokens(addr);
    debugLines.push(`Tronscan discovered ${tokens.length} tokens`);
    for(const t of tokens){
      // if no contract skip (rare)
      if(!t.contract) { debugLines.push(`skip token no contract: ${t.symbol}`); continue; }
      // if decimals missing, try on-chain decimals
      if(!t.decimals || isNaN(t.decimals)) {
        try{
          const c = await tronWebInstance.contract().at(t.contract);
          const d = await c.decimals().call().catch(()=>null); if(d!=null) t.decimals = Number(d?.toString?.() ?? d ?? 6);
        }catch(_) { t.decimals = t.decimals ?? 6; }
      }
      // if units suspiciously tiny, re-read balance on-chain
      if(!t.units || t.units < 0.0000001) {
        try {
          const c = await tronWebInstance.contract().at(t.contract);
          const raw = await c.balanceOf(addr).call();
          t.units = toNumberFromRaw(BigInt(raw?.toString?.() ?? raw ?? "0"), t.decimals ?? 6);
          debugLines.push(`Re-read on-chain for ${t.symbol}: ${t.units}`);
        } catch(e) { /* ignore */ }
      }

      if(!t.units || t.units <= 0) continue;

      // try price resolution
      const pr = await resolvePriceUsd(t);
      if(pr && pr.price != null){
        const usdVal = t.units * pr.price; grandTotal += usdVal; perWalletTotals[addr].subtotal += usdVal;
        perWalletTotals[addr].items.push({ symbol: t.symbol, contract: t.contract, amount: t.units, usd: usdVal, priceSource: pr.source });
        debugLines.push(`${t.symbol}: ${t.units} @ ${pr.price} (${pr.source}) => ${fmtUSD(usdVal)}`);
      } else {
        // last-ditch: try DEX fallback if not already tried
        let dexPrice = null;
        try { dexPrice = await readJustSwapPriceForToken(t.contract); } catch(e){ dexPrice = null; }
        if(dexPrice != null){
          const usdVal = t.units * dexPrice; grandTotal += usdVal; perWalletTotals[addr].subtotal += usdVal;
          perWalletTotals[addr].items.push({ symbol: t.symbol, contract: t.contract, amount: t.units, usd: usdVal, priceSource: "justswap" });
          debugLines.push(`${t.symbol}: ${t.units} @ ${dexPrice} (justswap) => ${fmtUSD(usdVal)}`);
        } else {
          perWalletTotals[addr].unpriced = perWalletTotals[addr].unpriced || [];
          perWalletTotals[addr].unpriced.push({ symbol: t.symbol, contract: t.contract, amount: t.units });
          unpriced.push({ wallet: addr, symbol: t.symbol, contract: t.contract, amount: t.units });
          debugLines.push(`${t.symbol}: ${t.units} => UNPRICED`);
        }
      }
      await sleep(30);
    }

    // explicit token contracts input by user
    for(const tc of explicitContracts){
      try{
        const cinfo = await (async (contract, owner) => {
          try {
            const c = await tronWebInstance.contract().at(contract);
            const d = await c.decimals().call().catch(()=>6);
            const s = await c.symbol().call().catch(()=>null);
            const raw = await c.balanceOf(owner).call();
            const units = toNumberFromRaw(BigInt(raw?.toString?.() ?? raw ?? "0"), Number(d ?? 6));
            return { contract, symbol: s? s.toString() : null, decimals: Number(d), units };
          } catch(e) { return { contract, symbol: null, decimals:6, units:0 }; }
        })(tc, addr);
        if(cinfo.units <= 0) continue;
        let priceObj = null;
        if(cinfo.symbol && ORACLE_BY_SYMBOL[cinfo.symbol.toUpperCase()]) {
          priceObj = { price: await readOraclePriceUSD(ORACLE_BY_SYMBOL[cinfo.symbol.toUpperCase()]), source: "oracle" };
        }
        if(!priceObj || !priceObj.price) {
          priceObj = await (async ()=>{ const p = await readJustSwapPriceForToken(tc); return p? { price: p, source: "justswap" } : null; })();
        }
        if(priceObj && priceObj.price != null) {
          const usdVal = cinfo.units * priceObj.price; grandTotal += usdVal; perWalletTotals[addr].subtotal += usdVal;
          perWalletTotals[addr].items.push({ symbol: cinfo.symbol || "(explicit)", contract: tc, amount: cinfo.units, usd: usdVal, priceSource: priceObj.source });
          debugLines.push(`Explicit ${cinfo.symbol||tc}: ${cinfo.units} @ ${priceObj.price} => ${fmtUSD(usdVal)}`);
        } else {
          perWalletTotals[addr].unpriced = perWalletTotals[addr].unpriced || [];
          perWalletTotals[addr].unpriced.push({ contract: tc, amount: cinfo.units });
          unpriced.push({ wallet: addr, contract: tc, amount: cinfo.units });
          debugLines.push(`Explicit ${tc}: ${cinfo.units} => UNPRICED`);
        }
      } catch(e) { console.warn("explicit token error", e); }
      await sleep(30);
    }

    // JustLend positions (optional)
    if(jlMarkets && jlMarkets.length){
      for(const j of jlMarkets){
        try{
          // read jToken position: balanceOf, decimals, exchangeRateStored/current, underlying()
          const j = await tronWebInstance.contract().at(j);
          let jBalRaw = 0n;
          try{ const b = await j.balanceOf(addr).call(); jBalRaw = BigInt(b?.toString?.() ?? b ?? "0"); }catch(_){}
          let jDecimals = 8; try{ const d = await j.decimals().call(); jDecimals = Number(d?.toString?.() ?? d ?? 8); }catch(_){}
          let exchangeRaw = null;
          try{ const ex = await j.exchangeRateStored().call(); exchangeRaw = BigInt(ex?.toString?.() ?? ex ?? "0"); }catch(_){ try{ const ex2 = await j.exchangeRateCurrent().call(); exchangeRaw = BigInt(ex2?.toString?.() ?? ex2 ?? "0"); }catch(_){ exchangeRaw = null; } }
          let underlyingContract = null;
          try{ const u = await j.underlying().call(); underlyingContract = u; }catch(_){ underlyingContract = null; }
          let underlyingDecimals = 6;
          if(underlyingContract){
            try{ const cu = await tronWebInstance.contract().at(underlyingContract); const d = await cu.decimals().call(); underlyingDecimals = Number(d?.toString?.() ?? d ?? 6); }catch(_){}
          }
          if(!exchangeRaw){
            const jUnits = toNumberFromRaw(jBalRaw, jDecimals);
            if(jUnits > 0){
              perWalletTotals[addr].unpriced = perWalletTotals[addr].unpriced || [];
              perWalletTotals[addr].unpriced.push({source:'justlend', jToken:j, amount:jUnits});
              unpriced.push({ wallet: addr, source:'justlend', jToken: j, amount:jUnits });
            }
          } else {
            const jUnits = toNumberFromRaw(jBalRaw, jDecimals);
            const exStr = exchangeRaw.toString();
            let exDecimalsGuess = 18; if(exStr.length <= 20) exDecimalsGuess = 6;
            const exchangeFloat = Number(exchangeRaw) / Math.pow(10, exDecimalsGuess);
            const underlyingAmount = jUnits * exchangeFloat;
            // try price underlying
            let priceObj = null;
            if(underlyingContract) {
              // try oracle by contract
              try {
                // try symbol
                const cu = await tronWebInstance.contract().at(underlyingContract);
                const sym = await cu.symbol().call().catch(()=>null);
                if(sym && ORACLE_BY_SYMBOL[sym.toString().toUpperCase()]) priceObj = { price: await readOraclePriceUSD(ORACLE_BY_SYMBOL[sym.toString().toUpperCase()]), source: "oracle" };
              } catch(_) {}
              if(!priceObj) {
                const dex = await readJustSwapPriceForToken(underlyingContract);
                if(dex) priceObj = { price: dex, source: "justswap" };
              }
            }
            if(priceObj && priceObj.price) {
              const usdVal = underlyingAmount * priceObj.price; grandTotal += usdVal; perWalletTotals[addr].subtotal += usdVal;
              perWalletTotals[addr].items.push({ source:'justlend', underlying: underlyingContract, amount: underlyingAmount, usd: usdVal, priceSource: priceObj.source });
              debugLines.push(`JustLend ${underlyingContract}: ${underlyingAmount} => ${fmtUSD(usdVal)} via ${priceObj.source}`);
            } else {
              perWalletTotals[addr].unpriced = perWalletTotals[addr].unpriced || [];
              perWalletTotals[addr].unpriced.push({ source:'justlend', jToken: j, amount: underlyingAmount, underlying: underlyingContract });
              unpriced.push({ wallet: addr, source:'justlend', jToken: j, amount: underlyingAmount, underlying: underlyingContract });
              debugLines.push(`JustLend ${underlyingContract}: ${underlyingAmount} => UNPRICED`);
            }
          }
        }catch(e){ console.warn("JustLend read error", e); }
        await sleep(40);
      }
    }

    debugLines.push(`Wallet subtotal: ${fmtUSD(perWalletTotals[addr].subtotal)}\n`);
    await sleep(80);
  } // wallets loop

  elGrand.textContent = `Grand Total: ${fmtUSD(grandTotal)}`;
  elPerWallet.innerHTML = Object.entries(perWalletTotals).map(([w,p]) => `${w}: ${fmtUSD(p.subtotal)}`).join(" â€¢ ");
  elStatus.textContent = "Done";

  // show unpriced clickable list (simple)
  if(unpriced.length){
    elUnpriced.innerHTML = unpriced.slice(0,200).map(u => `${u.symbol||u.contract||u.underlying||u.jToken||'unknown'}: ${u.amount}`).join("<br>");
  } else {
    elUnpriced.textContent = "All discovered tokens priced (or none unpriced)";
  }

  elDebug.textContent = debugLines.join("\n");
  lastResult = { grandTotal, perWalletTotals, unpriced, debug: debugLines, timestamp: Date.now() };
  console.log("DeFire result:", lastResult);
  return lastResult;
}

elBtnCalc.onclick = computeNetWorth;

</script>
</body>
</html>
